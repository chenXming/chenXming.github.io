<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>iOS-多线程使用总结 | chenXming的个人技术网站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一.概述与实现方案1. 线程与进程多线程在iOS中有着举足轻重的地位，是每一位开发者都必备的技能，当然也是面试常考的技术点，本文主要是探究我们实际开发或者面试中遇到的多线程问题。比如什么是线程？它跟进程是什么关系，队列跟线程什么关系，同步、异步、并发（并行）、串行这些概念又怎么来理解，iOS有哪些常用多线程方案，以及线程同步技术有哪些等等。  线程（英语：thread）是操作系统能够进行运算调度">
<meta property="og:type" content="article">
<meta property="og:title" content="iOS-多线程使用总结">
<meta property="og:url" content="https://chenxming.github.io/2022/06/16/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="chenXming的个人技术网站">
<meta property="og:description" content="一.概述与实现方案1. 线程与进程多线程在iOS中有着举足轻重的地位，是每一位开发者都必备的技能，当然也是面试常考的技术点，本文主要是探究我们实际开发或者面试中遇到的多线程问题。比如什么是线程？它跟进程是什么关系，队列跟线程什么关系，同步、异步、并发（并行）、串行这些概念又怎么来理解，iOS有哪些常用多线程方案，以及线程同步技术有哪些等等。  线程（英语：thread）是操作系统能够进行运算调度">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://i.loli.net/2021/06/25/5aihXZop3HEQuTU.png">
<meta property="og:image" content="https://i.loli.net/2021/06/25/DAehSErXHNW1cCJ.png">
<meta property="og:image" content="https://i.loli.net/2021/06/25/BFjIue9kngfc8qQ.jpg">
<meta property="article:published_time" content="2022-06-16T12:46:25.000Z">
<meta property="article:modified_time" content="2023-08-23T07:33:32.431Z">
<meta property="article:author" content="chenXming">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://i.loli.net/2021/06/25/5aihXZop3HEQuTU.png">
  
    <link rel="alternate" href="/atom.xml" title="chenXming的个人技术网站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">chenXming的个人技术网站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://chenxming.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-iOS多线程使用总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/06/16/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2022-06-16T12:46:25.000Z" itemprop="datePublished">2022-06-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      iOS-多线程使用总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <p><img src="https://i.loli.net/2021/06/25/5aihXZop3HEQuTU.png" alt="网络图片"></p>
<h3 id="一-概述与实现方案"><a href="#一-概述与实现方案" class="headerlink" title="一.概述与实现方案"></a>一.概述与实现方案</h3><h4 id="1-线程与进程"><a href="#1-线程与进程" class="headerlink" title="1. 线程与进程"></a>1. 线程与进程</h4><p>多线程在iOS中有着举足轻重的地位，是每一位开发者都必备的技能，当然也是面试常考的技术点，本文主要是探究我们实际开发或者面试中遇到的多线程问题。比如什么是线程？它跟进程是什么关系，队列跟线程什么关系，<code>同步、异步、并发（并行）、串行</code>这些概念又怎么来理解，iOS有哪些常用多线程方案，以及线程同步技术有哪些等等。</p>
<blockquote>
<p>线程（英语：thread）是操作系统能够进行运算调度的最小单位。大部分情况下，它被包含在进程之中，是进程中的实际运作单位。一条线程指的是进程中一个单一顺序的控制流，一个进程中可以并发多个线程，每条线程并行执行不同的任务。   — 维基百科</p>
</blockquote>
<p>这里又多了一个 <code>进程</code>,那什么是进程呢,说白了就是是指在操作系统中正在运行的一个应用程序，如微信、支付宝app等都是一个进程。线程是就是进程的基本执行单元，一个进程的所有任务都在线程中执行。也就是说 一个进程最少要有一个线程，这个线程就是主线程。当然在我们实际使用过程中不可能只有一条主线程，我们为提高程序的执行效率，往往需要开辟多条子线程去执行一些耗时任务，这里就引出了多线程的概念。</p>
<blockquote>
<p>多线程（英语：multithreading），是指从软件或者硬件上实现多个线程并发执行的技术</p>
</blockquote>
<p>根据操作系统与硬件的不同分为两类：<code>软件多线程</code>与<code>硬件多线程</code></p>
<ul>
<li><p>软件多线程: 即便CPU只能运行一个线程，操作系统也可以通过快速的在不同线程之间进行切换，由于时间间隔很小，来给用户造成一种多个线程同时运行的假象</p>
</li>
<li><p>硬件多线程: 如果CPU有多个核心，操作系统可以让每个核心执行一条线程，从而具有真正的同时执行多个线程的能力，当然由于任务数量远远多于CPU的核心数量，所以，操作系统也会自动把很多任务轮流调度到每个核心上执行。<br>以上都是google出来的一大堆东西，比较抽象，没关系我们来看下我们实际iOS开发中用到的多线程技术。</p>
</li>
</ul>
<h4 id="2-iOS中的多线程方案"><a href="#2-iOS中的多线程方案" class="headerlink" title="2.iOS中的多线程方案"></a>2.iOS中的多线程方案</h4><p>iOS 中的多线程方案主要有四种 <code>PThread</code>、<code>NSThread</code>、<code>GCD</code>、<code>NSOperation</code>，<code>PThread</code> 是一套纯粹<code>C</code>语言的API，能适用于Unix\Linux\Windows等系统,线程生命周期需要程序员自己管理，使用难度较大，在我们的实际开发中几乎用不到，在这里我们不做过多介绍，感兴趣的直接去百度。我们着重介绍另外三中方案。</p>
<blockquote>
<p>这里解释一下线程的生命周期，所谓的线程的生命周期就是线程从创建到死亡的过程。一般会经历：<code>新建 - 就绪 - 运行 - 阻塞 - 死亡</code>的过程。</p>
</blockquote>
<ul>
<li>新建：就是初始化线程对象</li>
<li>就绪：向线程对象发送start消息，线程对象被加入可调度线程池等待CPU调度。</li>
<li>运行：CPU 负责调度可调度线程池中线程的执行，线程执行完成之前，状态可能会在就绪和运行之间来回切换。就绪和运行之间的状态变化由CPU负责，程序员不能干预。</li>
<li>阻塞：当满足某个预定条件时，可以使用休眠或锁，阻塞线程执行</li>
<li>死亡：线程执行完毕，退出，销毁。</li>
</ul>
<h5 id="1-NSThread"><a href="#1-NSThread" class="headerlink" title="(1) NSThread"></a>(1) <code>NSThread</code></h5><p>NSThread是苹果官方提供面向对象操作线程的技术，简单方便，可以直接操作线程对象，不过需要自己控制线程的生命周期，我们看下苹果官方给出的方法。</p>
<h6 id="1-初始化方法"><a href="#1-初始化方法" class="headerlink" title="[1] 初始化方法"></a>[1] 初始化方法</h6><ul>
<li>实例初始化方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (instancetype)init API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0)) NS_DESIGNATED_INITIALIZER;</span><br><span class="line">- (instancetype)initWithTarget:(id)target selector:(SEL)selector object:(nullable id)argument API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">- (instancetype)initWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line"></span><br></pre></td></tr></table></figure>
对应的初始化方法：</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">//创建线程</span><br><span class="line">NSThread *newThread = [[NSThread  alloc]initWithTarget:self selector:@selector(demo:) object:@&quot;Thread&quot;];</span><br><span class="line">NSThread *newThread = [[NSThread alloc]init];</span><br><span class="line">NSThread *newThread = [[NSThread alloc]initWithBlock:^&#123;</span><br><span class="line">    NSLog(@&quot;Block&quot;);</span><br><span class="line">&#125;];</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意三种方法创建完成后都需要执行 <code>[newThread start]</code> 去启动线程。</p>
</blockquote>
<ul>
<li>类初始化方法<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">+ (void)detachNewThreadWithBlock:(void (^)(void))block API_AVAILABLE(macosx(10.12), ios(10.0), watchos(3.0), tvos(10.0));</span><br><span class="line">+ (void)detachNewThreadSelector:(SEL)selector toTarget:(id)target withObject:(nullable id)argument;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意这两个类方法创建后就可执行，不需手动开启</p>
</blockquote>
</li>
</ul>
<h6 id="2-取消退出"><a href="#2-取消退出" class="headerlink" title="[2] 取消退出"></a>[2] 取消退出</h6><p>既然有了创建，那就得有退出</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// 实例方法 取消线程</span><br><span class="line">- (void)cancel;</span><br><span class="line">//类方法 退出</span><br><span class="line">+ (void)exit;</span><br></pre></td></tr></table></figure>
<h6 id="3-线程执行状态"><a href="#3-线程执行状态" class="headerlink" title="[3] 线程执行状态"></a>[3] 线程执行状态</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">// 线程正在执行</span><br><span class="line">@property (readonly, getter=isExecuting) BOOL executing API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">// 线程执行结束</span><br><span class="line">@property (readonly, getter=isFinished) BOOL finished API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">// 线程是否可取消</span><br><span class="line">@property (readonly, getter=isCancelled) BOOL cancelled API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br></pre></td></tr></table></figure>
<h6 id="4-线程间的通信方法"><a href="#4-线程间的通信方法" class="headerlink" title="[4] 线程间的通信方法"></a>[4] 线程间的通信方法</h6><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">@interface NSObject (NSThreadPerformAdditions)</span><br><span class="line">/*</span><br><span class="line">* 去主线程执行指定方法</span><br><span class="line">* aSelector: 方法</span><br><span class="line">* arg: 参数</span><br><span class="line">* wait:表示是否等待主线程做完事情后往下走，YES表示做完后执行下面事情，NO表示跟下面事情一起执行</span><br><span class="line">*/</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array;</span><br><span class="line">- (void)performSelectorOnMainThread:(SEL)aSelector withObject:(nullable id)arg waitUntilDone:(BOOL)wait;</span><br><span class="line">/*</span><br><span class="line">* 去指定线程执行指定方法</span><br><span class="line">* aSelector: 方法</span><br><span class="line">* arg: 参数</span><br><span class="line">* wait:表示是否等待本线程做完事情后往下走，YES表示做完后执行下面事，NO表示跟下面事一起执行</span><br><span class="line">*/</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait modes:(nullable NSArray&lt;NSString *&gt; *)array API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">- (void)performSelector:(SEL)aSelector onThread:(NSThread *)thr withObject:(nullable id)arg waitUntilDone:(BOOL)wait API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line">/*</span><br><span class="line">* 去开启的子线程执行指定方法</span><br><span class="line">* SEL: 方法</span><br><span class="line">* arg: 参数</span><br><span class="line">*/</span><br><span class="line">- (void)performSelectorInBackground:(SEL)aSelector withObject:(nullable id)arg API_AVAILABLE(macos(10.5), ios(2.0), watchos(2.0), tvos(9.0));</span><br><span class="line"></span><br><span class="line">@end</span><br></pre></td></tr></table></figure>
<p>我们常说的线程间的通信所用的方法其实就是上面的这几个方法，所有继承NSObject实例化对象都可调用。当然还有其他方法也可以实现线程间的通信，如：<code>GCD</code>、<code>NSOperation</code>、<code>NSMachPort</code>端口等形式，我们后面用到在做介绍。<br>举个简单的例子：我们在子线程中下载图片，然后去主线程展示：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">- (void)touchesBegan:(NSSet&lt;UITouch *&gt; *)touches withEvent:(UIEvent *)event &#123;</span><br><span class="line">    // 子线程执行下载方法</span><br><span class="line">    [self performSelectorInBackground:@selector(download) withObject:nil];</span><br><span class="line">&#125;</span><br><span class="line">- (void)download&#123;</span><br><span class="line">    //图片的网络路径</span><br><span class="line">     NSURL *url = [NSURL URLWithString:@&quot;https://p3.ssl.qhimg.com/t011e94f0b9ed8e66b0.png&quot;];</span><br><span class="line">     //下载图片数据</span><br><span class="line">     NSData *data = [NSData dataWithContentsOfURL:url];</span><br><span class="line">     //生成图片</span><br><span class="line">     UIImage *image = [UIImage imageWithData:data];</span><br><span class="line">    // 回主线程显示图片</span><br><span class="line">    [self performSelectorOnMainThread:@selector(showImage:) withObject:image waitUntilDone:YES];</span><br><span class="line">&#125;</span><br><span class="line">- (void)showImage:(UIImage *)image&#123;</span><br><span class="line">    self.imageView.image = image;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h6 id="5-其他常用方法"><a href="#5-其他常用方法" class="headerlink" title="[5] 其他常用方法"></a>[5] 其他常用方法</h6><ul>
<li><code>+(void)currentThread</code> 获取当前线程</li>
<li><code>+(BOOL)isMultiThreaded</code> 判断当前是否运行在子线程</li>
<li><code>-(BOOL)isMainThread</code> 判断是否在主线程</li>
<li><code>+(void)sleepUntilDate:(NSDate *)date;+ (void)sleepForTimeInterval:(NSTimeInterval)ti;</code> 当前线程休眠时间</li>
</ul>
<h5 id="3-GCD"><a href="#3-GCD" class="headerlink" title="(3). GCD"></a>(3). GCD</h5><p>在介绍<code>GCD</code>前我们先来了解下多线程中比较容易混淆的几个概念</p>
<h6 id="1-同步、异步、并发（并行）、串行"><a href="#1-同步、异步、并发（并行）、串行" class="headerlink" title="[1]. 同步、异步、并发（并行）、串行"></a>[1]. 同步、异步、并发（并行）、串行</h6><ul>
<li><p>同步和异步主要影响：能不能开启新的线程<br>同步：在当前线程中执行任务，不具备开启新线程的能力<br>异步：在新的线程中执行任务，具备开启新线程的能力</p>
</li>
<li><p>并发和串行主要影响：任务的执行方式<br>并发：也叫并行，也叫并行队列，多个任务并发（同时）执行<br>串行：也叫串行队列，一个任务执行完毕后，再执行下一个任务</p>
</li>
</ul>
<p>单纯的介绍概念比较抽象，我们还是结合实际使用来说明：<br></p>
<h6 id="2-GCD-中的同步、异步方法"><a href="#2-GCD-中的同步、异步方法" class="headerlink" title="[2] GCD 中的同步、异步方法"></a>[2] GCD 中的同步、异步方法</h6><ul>
<li>同步执行方法：<code>dispatch_sync()</code></li>
<li>异步执行方法：<code>dispatch_async()</code><br>使用方法：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">dispatch_sync(<span class="type">dispatch_queue_t</span> <span class="built_in">queue</span>, DISPATCH_NOESCAPE <span class="type">dispatch_block_t</span> block);</span><br><span class="line">dispatch_async(<span class="type">dispatch_queue_t</span> <span class="built_in">queue</span>, <span class="type">dispatch_block_t</span> block);</span><br></pre></td></tr></table></figure>
可以看到这个两个方法需要两个参数，第一个参数需要传入一个<code>dispatch_queue_t</code> 类型的队列，第二个是执行的block。下面介绍一下GCD的队列</li>
</ul>
<h6 id="3-GCD-中的队列"><a href="#3-GCD-中的队列" class="headerlink" title="[3] GCD 中的队列"></a>[3] GCD 中的队列</h6><p>GCD中的队列有三种：<code>串行队列、并行队列、主队列</code>，创建方式也非常简单：</p>
<ul>
<li>串行队列<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span> queue1 = dispatch_queue_create(<span class="string">&quot;myQueue&quot;</span>, DISPATCH_QUEUE_SERIAL);</span><br></pre></td></tr></table></figure>
第一个参数是队列名称，第二个是一个宏定义，常用的两个宏 <code>DISPATCH_QUEUE_SERIAL</code> 和 <code>DISPATCH_QUEUE_CONCURRENT</code>分别表示串行队列和并行队列,除此之外，宏<code>DISPATCH_QUEUE_SERIAL_INACTIVE</code> 和 <code>DISPATCH_QUEUE_CONCURRENT_INACTIVE</code> 分别表示初始化的串行队列和并行队列处于不可活动状态。看下它的底层实现<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_attr_t</span></span><br><span class="line"><span class="title function_">dispatch_queue_attr_make_initially_inactive</span><span class="params">(</span></span><br><span class="line"><span class="params">		<span class="type">dispatch_queue_attr_t</span> _Nullable attr)</span>;</span><br><span class="line">		</span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_SERIAL_INACTIVE \</span></span><br><span class="line"><span class="meta">		dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_SERIAL)</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> DISPATCH_QUEUE_CONCURRENT_INACTIVE \</span></span><br><span class="line"><span class="meta">		dispatch_queue_attr_make_initially_inactive(DISPATCH_QUEUE_CONCURRENT)</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>应当注意的是，初始化后处于不可活动状态的队列，添加到其中的任务要想开始执行，必须先调用 <code>dispatch_activate()</code>函数使其状态变更为可活动状态.</p>
</blockquote>
</li>
<li>并行队列<br>并行队列有两种：<br><br>第一种：全局并发队列创建方法,也是系统为我们创建好的并发队列，创建方式</li>
</ul>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*  - QOS_CLASS_USER_INTERACTIVE</span></span><br><span class="line"><span class="comment"> *  - QOS_CLASS_USER_INITIATED</span></span><br><span class="line"><span class="comment"> *  - QOS_CLASS_DEFAULT</span></span><br><span class="line"><span class="comment"> *  - QOS_CLASS_UTILITY</span></span><br><span class="line"><span class="comment"> *  - QOS_CLASS_BACKGROUND</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="comment">//dispatch_get_global_queue(intptr_t identifier, uintptr_t flags); </span></span><br><span class="line"></span><br><span class="line"><span class="type">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_global_queue(<span class="number">0</span>,<span class="number">0</span>);</span><br></pre></td></tr></table></figure>
<p>这里有两个参数,第一个参数标识线程执行优先级，第二个是苹果保留参数传参：0 就可以。<br><br>第二种：手动创建并发队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 串行执行，第一个参数是名称 ，第二个是标识：DISPATCH_QUEUE_CONCURRENT,并发队列标识</span></span><br><span class="line"><span class="type">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_queue_create(<span class="string">&quot;myQueue&quot;</span>,DISPATCH_QUEUE_CONCURRENT);</span><br></pre></td></tr></table></figure>
<ul>
<li>主队列<br>主队列是一种特殊的串行队列<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">dispatch_queue_t</span> <span class="built_in">queue</span> = dispatch_get_main_queue();</span><br></pre></td></tr></table></figure>
同步、异步以及队列的组合就可以实现对任务进行多线程编程的需求了。</li>
</ul>
<ol>
<li><p>同步串行队列</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  dispatch_queue_t queue1 = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    for(NSInteger i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        dispatch_sync(queue1, ^&#123;</span><br><span class="line">            NSLog(@&quot;thread == %@ i====%ld&quot;,[NSThread currentThread],(long)i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">//thread == &lt;NSThread: 0x6000011b8880&gt;&#123;number = 1, name = main&#125; i====n</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到没有开启新的线程，都是在主线程中执行任务,并且是顺序执行的</p>
</blockquote>
</li>
<li><p>同步并行队列</p>
</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for(NSInteger i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        dispatch_sync(queue1, ^&#123;</span><br><span class="line">            NSLog(@&quot;thread == %@ i====%ld&quot;,[NSThread currentThread],(long)i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">// thread == &lt;NSThread: 0x600001db8a00&gt;&#123;number = 1, name = main&#125; i====n</span><br></pre></td></tr></table></figure>
<blockquote>
<p>也是在主线程中顺序执行。<br>3. 异步串行队列</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue1 = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    for(NSInteger i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        dispatch_async(queue1, ^&#123;</span><br><span class="line">            NSLog(@&quot;thread == %@ i====%ld&quot;,[NSThread currentThread],(long)i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开启子线程，顺序执行任务<br>4. 异步并发队列</p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"> dispatch_queue_t queue1 = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">    for(NSInteger i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        dispatch_async(queue1, ^&#123;</span><br><span class="line">            NSLog(@&quot;thread == %@ i====%ld&quot;,[NSThread currentThread],(long)i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">/*</span><br><span class="line">thread == &lt;NSThread: 0x6000024f9440&gt;&#123;number = 4, name = (null)&#125; i====0</span><br><span class="line">thread == &lt;NSThread: 0x6000024f5340&gt;&#123;number = 5, name = (null)&#125; i====2</span><br><span class="line">thread == &lt;NSThread: 0x6000024a8780&gt;&#123;number = 3, name = (null)&#125; i====3</span><br><span class="line">thread == &lt;NSThread: 0x6000024ac6c0&gt;&#123;number = 6, name = (null)&#125; i====1</span><br><span class="line">thread == &lt;NSThread: 0x6000024f4a80&gt;&#123;number = 8, name = (null)&#125; i====5</span><br><span class="line">thread == &lt;NSThread: 0x6000024b0b40&gt;&#123;number = 7, name = (null)&#125; i====4</span><br><span class="line">thread == &lt;NSThread: 0x60000249cd00&gt;&#123;number = 9, name = (null)&#125; i====6</span><br><span class="line">thread == &lt;NSThread: 0x6000024b0980&gt;&#123;number = 10, name = (null)&#125; i====7</span><br><span class="line">thread == &lt;NSThread: 0x6000024cb900&gt;&#123;number = 11, name = (null)&#125; i====8</span><br><span class="line">thread == &lt;NSThread: 0x6000024f5340&gt;&#123;number = 5, name = (null)&#125; i====9</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>开启了多个子线程，并且是并发执行任务。</p>
</blockquote>
<p>注意 <code>dispatch_async()</code>具备开辟新线程的能力，但是不表示使用它就一定会开辟新的线程。 例如 传入的 queue 是主队列,就是在主线程中执行任务,没有开辟新线程。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  dispatch_queue_t queue1 = dispatch_get_main_queue();</span><br><span class="line">    for(NSInteger i = 0; i &lt; 10; i++)&#123;</span><br><span class="line">        sleep(2);</span><br><span class="line">        dispatch_async(queue1, ^&#123;</span><br><span class="line">            NSLog(@&quot;thread == %@ i====%ld&quot;,[NSThread currentThread],(long)i);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">//thread == &lt;NSThread: 0x600002b24880&gt;&#123;number = 1, name = main&#125; i====n</span><br></pre></td></tr></table></figure>
<blockquote>
<p>主队列是一种特殊的串行队列，从打印结果看出，这里执行方式是串行，而且没有开启新的线程。</p>
</blockquote>
<p>具体任务的执行方式可以参考下面的表格<br><img src="https://i.loli.net/2021/06/25/DAehSErXHNW1cCJ.png" alt="执行方式"></p>
<h6 id="4-dispatch-group-t-队列组"><a href="#4-dispatch-group-t-队列组" class="headerlink" title="[4] dispatch_ group_ t 队列组"></a>[4] dispatch_ group_ t 队列组</h6><p><code>dispatch_group_t</code>是一个比较实用的方法，通过构造一个组的形式，将各个同步或异步提交任务都加入到同一个组中，当所有任务都完成后会收到通知，用于进一步处理.举个简单的例子如下:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">dispatch_group_t group = dispatch_group_create();</span><br><span class="line"></span><br><span class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;Task1 %@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;Task2 %@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_async(group, concurrentQueue, ^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 10; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;Task3 %@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    dispatch_group_notify(group, concurrentQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;All Task Complete&quot;);</span><br><span class="line">    &#125;);</span><br></pre></td></tr></table></figure>
<h6 id="5-diapatch-barrier-async-栅栏异步调用函数"><a href="#5-diapatch-barrier-async-栅栏异步调用函数" class="headerlink" title="[5] diapatch_barrier_async 栅栏异步调用函数"></a>[5] diapatch_barrier_async 栅栏异步调用函数</h6><p>有异步调用就也有同步调用函数<code>diapatch_barrier_sync()</code>，两者的区别：<code>dispatch_barrier_sync</code> 需要等待栅栏执行完才会执行栅栏后面的任务,而<code>dispatch_barrier_async</code> 无需等待栅栏执行完,会继续往下走，有什么用呢？其实栅栏函数用的最多的地方还是实现线程同步使用，比如我们有这样一个需求：怎么样利用GCD实现多读单写文件的IO操作？也就是怎么样实现多读单写，看代码：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">@interface UserCenter()</span><br><span class="line">&#123;</span><br><span class="line">    // 定义一个并发队列</span><br><span class="line">    dispatch_queue_t concurrent_queue;</span><br><span class="line">    </span><br><span class="line">    // 用户数据中心, 可能多个线程需要数据访问</span><br><span class="line">    NSMutableDictionary *userCenterDic;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// 多读单写模型</span><br><span class="line">@implementation UserCenter</span><br><span class="line"></span><br><span class="line">- (id)init</span><br><span class="line">&#123;</span><br><span class="line">    self = [super init];</span><br><span class="line">    if (self) &#123;</span><br><span class="line">        // 通过宏定义 DISPATCH_QUEUE_CONCURRENT 创建一个并发队列</span><br><span class="line">        concurrent_queue = dispatch_queue_create(&quot;read_write_queue&quot;, DISPATCH_QUEUE_CONCURRENT);</span><br><span class="line">        // 创建数据容器</span><br><span class="line">        userCenterDic = [NSMutableDictionary dictionary];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    return self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (id)objectForKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    __block id obj;</span><br><span class="line">    // 同步读取指定数据,立刻返回读取结果</span><br><span class="line">    dispatch_sync(concurrent_queue, ^&#123;</span><br><span class="line">        obj = [userCenterDic objectForKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">    </span><br><span class="line">    return obj;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)setObject:(id)obj forKey:(NSString *)key</span><br><span class="line">&#123;</span><br><span class="line">    // 异步栅栏调用设置数据</span><br><span class="line">    dispatch_barrier_async(concurrent_queue, ^&#123;</span><br><span class="line">        [userCenterDic setObject:obj forKey:key];</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>可以看到把写操作放入栅栏函数，可以实现线程同步效果<br>注意：使用<code>dispatch_barrier_async</code> ，该函数只能搭配自定义并发队列 <code>dispatch_queue_t</code> 使用。不能使用全局并发队列： <code>dispatch_get_global_queue</code>，否则 <code>dispatch_barrier_async</code>无作用。</p>
</blockquote>
<h6 id="6-线程死锁"><a href="#6-线程死锁" class="headerlink" title="[6] 线程死锁"></a>[6] 线程死锁</h6><p>先来看两个例子：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">dispatch_queue_t queue = dispatch_get_main_queue();</span><br><span class="line">    dispatch_sync(queue, ^&#123;</span><br><span class="line">        NSLog(@&quot;执行任务2&quot;);</span><br><span class="line">    &#125;);// 往主线程里面 同步添加任务 会发生死锁现象</span><br><span class="line"></span><br><span class="line"> dispatch_queue_t myQueue = dispatch_queue_create(&quot;myQueue&quot;, DISPATCH_QUEUE_SERIAL);</span><br><span class="line">    </span><br><span class="line">    dispatch_async(myQueue, ^&#123;</span><br><span class="line">        NSLog(@&quot;1111,thread====%@&quot;,[NSThread currentThread]);</span><br><span class="line">        </span><br><span class="line">        dispatch_sync(myQueue, ^&#123;</span><br><span class="line">            NSLog(@&quot;2222,thread====%@&quot;,[NSThread currentThread]);</span><br><span class="line">        &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">// 1111,thread====&lt;NSThread: 0x6000022dd880&gt;&#123;number = 5, name = (null)&#125; </span><br><span class="line">// crash</span><br></pre></td></tr></table></figure>
<blockquote>
<p>上面的例子可以看出，不能向当前的串行队列，同步添加任务，否则会产生死锁导致crash。线程死锁的条件：使用sync函数往当前串行队列里面添加任务，会产生死锁。</p>
</blockquote>
<h5 id="4-NSOperation"><a href="#4-NSOperation" class="headerlink" title="(4). NSOperation"></a>(4). NSOperation</h5><p>NSOperation 是苹果对GCD面向对象的封装，它的底层是基于<code>GCD</code>实现的，相比于GCD它添加了更多实用的功能</p>
<ul>
<li>可以添加任务依赖</li>
<li>任务执行状态的控制</li>
<li>设置最大并发数<br>它有两个核心类分别是<code>NSOperation</code>和<code>NSOperationQueue</code>，NSOperation就是对任务进行的封装，封装好的任务交给不同的NSOperationQueue即可进行串行队列的执行或并发队列的执行。</li>
</ul>
<h6 id="1-NSOperation"><a href="#1-NSOperation" class="headerlink" title="[1] NSOperation"></a>[1] NSOperation</h6><p>NSOperation 是一个抽象类，并不能直接实用，必须使用它的子类，有三种方式：<code>NSInvocationOperation</code>、<code>NSBlockOperation</code>、<code>自定义子类继承NSOperation</code>,前两中是苹果为我们封装好的，可以直接使用，自定义子类，需要我们实现相应的方法。</p>
<ul>
<li>NSBlockOperation &amp; NSInvocationOperation<br>使用：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">//创建一个NSBlockOperation对象，传入一个block</span><br><span class="line">NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">    for (int i = 0; i &lt; 5; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        NSLog(@&quot;Task1 %@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;];</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line">创建一个NSInvocationOperation对象，指定执行的对象和方法</span><br><span class="line">该方法可以接收一个参数即object</span><br><span class="line">*/</span><br><span class="line">NSInvocationOperation *invocationOperation = [[NSInvocationOperation alloc] initWithTarget:self selector:@selector(task:) object:@&quot;Hello, World!&quot;];</span><br><span class="line"></span><br><span class="line">// 执行</span><br><span class="line">[operation start];</span><br><span class="line">[invocationOperation start];</span><br><span class="line"></span><br><span class="line">// 打印： Task1 &lt;NSThread: 0x6000019581c0&gt;&#123;number = 1, name = main&#125; 0</span><br></pre></td></tr></table></figure>
可以看到创建这两个任务对象去执行任务，并没有开启新线程。NSBlockOperation 相比 NSInvocationOperation 多了个<code>addExecutionBlock</code> 追加任务的方法，<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"> NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;task1=====%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">       </span><br><span class="line">        NSLog(@&quot;task2=====%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">       </span><br><span class="line">        NSLog(@&quot;task3=====%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [operation addExecutionBlock:^&#123;</span><br><span class="line">       </span><br><span class="line">        NSLog(@&quot;task4=====%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    [operation start];</span><br><span class="line">/*</span><br><span class="line">task3=====&lt;NSThread: 0x600000509840&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">task4=====&lt;NSThread: 0x600000530200&gt;&#123;number = 3, name = (null)&#125;</span><br><span class="line">task1=====&lt;NSThread: 0x600000558880&gt;&#123;number = 1, name = main&#125; 0</span><br><span class="line">task2=====&lt;NSThread: 0x600000511680&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">task1=====&lt;NSThread: 0x600000558880&gt;&#123;number = 1, name = main&#125; 1</span><br><span class="line">task1=====&lt;NSThread: 0x600000558880&gt;&#123;number = 1, name = main&#125; 2</span><br><span class="line">task1=====&lt;NSThread: 0x600000558880&gt;&#123;number = 1, name = main&#125; 3</span><br><span class="line">task1=====&lt;NSThread: 0x600000558880&gt;&#123;number = 1, name = main&#125; 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<blockquote>
<p>使用<code>addExecutionBlock</code>追加的任务是并发执行的,如果这个操作的任务数大于1那么会开启子线程并发执行任务，这里追加的任务不一定就是子线程，也有可能是主线程。</p>
</blockquote>
</li>
</ul>
<h6 id="2-NSOperationQueue"><a href="#2-NSOperationQueue" class="headerlink" title="[2] NSOperationQueue"></a>[2] NSOperationQueue</h6><p>NSOperationQueue 有两种队列，一个是主队列通过<code>[NSOperationQueue mainQueue]</code> 获取，还有一个是自己创建的队列<code>[[NSOperationQueue alloc] init]</code>,它同时具备并发跟串行的能力，可以通过设置最大并发数来决定。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"> NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;task1=====%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;Task2===== %@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSOperationQueue *queues = [[NSOperationQueue alloc] init];</span><br><span class="line">    [queues setMaxConcurrentOperationCount:2];//设置最大并发数，如果设置为1则串行执行</span><br><span class="line">    [queues addOperation:operation];</span><br><span class="line">    [queues addOperation:operation2];</span><br><span class="line">/*</span><br><span class="line">Task2===== &lt;NSThread: 0x600000489940&gt;&#123;number = 4, name = (null)&#125; 0</span><br><span class="line">task1=====&lt;NSThread: 0x6000004e15c0&gt;&#123;number = 5, name = (null)&#125; 0</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>这个例子有两个任务，如果设置最大并发数为2，则会开辟两个线程，并发执行这两个任务。如果设置为1，则会在新的线程中串行执行。</p>
<h6 id="3-任务依赖"><a href="#3-任务依赖" class="headerlink" title="[3] 任务依赖"></a>[3] 任务依赖</h6><p><code>addDependency</code>可以建立两个任务之间的依赖关系，如<code>[operation2 addDependency:operation1];</code> 为任务2依赖任务1，必须等任务1执行完成后才会执行任务2，看个例子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">  NSBlockOperation *operation = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;task1=====%@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSBlockOperation *operation2 = [NSBlockOperation blockOperationWithBlock:^&#123;</span><br><span class="line">        for (int i = 0; i &lt; 5; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            NSLog(@&quot;Task2===== %@ %d&quot;, [NSThread currentThread], i);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">    </span><br><span class="line">    NSOperationQueue *queues = [[NSOperationQueue alloc] init];</span><br><span class="line">    [queues setMaxConcurrentOperationCount:2];</span><br><span class="line">    //设置任务依赖</span><br><span class="line">    [operation addDependency:operation2];</span><br><span class="line">    </span><br><span class="line">    [queues addOperation:operation];</span><br><span class="line">    [queues addOperation:operation2];</span><br><span class="line">/*</span><br><span class="line">Task2===== &lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 0</span><br><span class="line">Task2===== &lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 1</span><br><span class="line">Task2===== &lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 2</span><br><span class="line">Task2===== &lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 3</span><br><span class="line">Task2===== &lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 4</span><br><span class="line">task1=====&lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 0</span><br><span class="line">task1=====&lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 1</span><br><span class="line">task1=====&lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 2</span><br><span class="line">task1=====&lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 3</span><br><span class="line">task1=====&lt;NSThread: 0x6000005b5dc0&gt;&#123;number = 6, name = (null)&#125; 4</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>还是已上面的例子，设置<code>[operation addDependency:operation2];</code>,可以看到任务2完成后才会执行任务1的操作。</p>
<h6 id="4-自定义NSOperation"><a href="#4-自定义NSOperation" class="headerlink" title="[4] 自定义NSOperation"></a>[4] 自定义NSOperation</h6><p>任务执行状态的控制是相对于自定义的NSOperation子类来说的。对于自定义NSOperation子类有两种类型：<br></p>
<ol>
<li>重写<code>main</code>方法<br>只重写<code>operation</code>的main方法,main方法里面写要执行的任务，系统底层控制变更任务执行完成状态，以及任务的退出。看个例子</li>
</ol>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#import &quot;TestOperation.h&quot;</span><br><span class="line"></span><br><span class="line">@interface TestOperation ()</span><br><span class="line">@property (nonatomic, copy) id obj;</span><br><span class="line"></span><br><span class="line">@end</span><br><span class="line"></span><br><span class="line">@implementation TestOperation</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObject:(id)obj&#123;</span><br><span class="line">    if(self = [super init])&#123;</span><br><span class="line">        self.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    return  self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)main&#123;</span><br><span class="line">    NSLog(@&quot;开始执行任务%@ thread===%@&quot;,self.obj,[NSThread currentThread]);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>调用</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">  TestOperation *operation4 = [[TestOperation alloc] initWithObject:[NSString stringWithFormat:@&quot;我是任务4&quot;]];</span><br><span class="line">    [operation4 setCompletionBlock:^&#123;</span><br><span class="line">        NSLog(@&quot;执行完成 thread===%@&quot;,[NSThread currentThread]);</span><br><span class="line">    &#125;];</span><br><span class="line">    [operation4 start];</span><br><span class="line">// 打印</span><br><span class="line">开始执行任务我是任务4 thread===&lt;NSThread: 0x6000008d8880&gt;&#123;number = 1, name = main&#125;</span><br><span class="line">执行完成 thread===&lt;NSThread: 0x60000089fa40&gt;&#123;number = 7, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>可以看到任务operation的main方法执行是在主线程中的，只是最后完成后的回调<code>setCompletionBlock</code>是异步的，好像没什么用，别着急，我们把他放入队列中执行看下，还是上面的例子,加入队列执行</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"> NSOperationQueue *queue4 = [[NSOperationQueue alloc] init];</span><br><span class="line"> TestOperation *operation4 = [[TestOperation alloc] initWithObject:[NSString stringWithFormat:@&quot;我是任务4&quot;]];</span><br><span class="line"> TestOperation *operation5 = [[TestOperation alloc] initWithObject:[NSString stringWithFormat:@&quot;我是任务5&quot;]];</span><br><span class="line"> TestOperation *operation6 = [[TestOperation alloc] initWithObject:[NSString stringWithFormat:@&quot;我是任务6&quot;]];</span><br><span class="line"></span><br><span class="line"> [queue4 addOperation:operation4];</span><br><span class="line"> [queue4 addOperation:operation5];</span><br><span class="line"> [queue4 addOperation:operation6];</span><br><span class="line">//打印：</span><br><span class="line">开始执行任务我是任务6 thread===&lt;NSThread: 0x600001fc8200&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">开始执行任务我是任务4 thread===&lt;NSThread: 0x600001fcc040&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">开始执行任务我是任务5 thread===&lt;NSThread: 0x600001fd7c80&gt;&#123;number = 7, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>这时候可以看到任务的并发执行了，operation的main方法执行结束后就会调用各自的<code>dealloc</code>方法进行释放，任务的生命周期结束。如果我们想让任务4、5、6 倒序执行，可以添加任务依赖</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> [operation4 addDependency:operation5];</span><br><span class="line"> [operation5 addDependency:operation6];</span><br><span class="line">// 打印</span><br><span class="line">开始执行任务我是任务6 thread===&lt;NSThread: 0x600003d04680&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">开始执行任务我是任务5 thread===&lt;NSThread: 0x600003d04680&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">开始执行任务我是任务4 thread===&lt;NSThread: 0x600003d04680&gt;&#123;number = 6, name = (null)&#125;</span><br></pre></td></tr></table></figure>
<p>这样做貌似是可以的，但是如果我们的operation 中又存在异步任务（如网络请求），我们想让网络任务6请求完后调用任务5，任务5调用成功后调任务4，那该怎么办呢，我们先卖个关子，我们在第二节<code>多个请求完成后继续进行下一个请求的方法总结</code>中介绍。<br>2. 重写<code>start</code>方法<br>通过重写<code>main</code>方法可以实现任务的串行执行，如果要让任务并发执行，就需要重写<code>start</code>方法。两者还是有很大区别的：<br>如果只是重写main方法，方法执行完毕，那么整个operation就会从队列中被移除。如果你是一个自定义的operation并且它是某些类的代理，这些类恰好有异步方法，这时就会找不到代理导致程序出错了。然而start方法就算执行完毕，它的finish属性也不会变，因此你可以控制这个operation的生命周期了。然后在任务完成之后手动cancel掉这个operation即可。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line">@interface TestStartOperation : NSOperation</span><br><span class="line">- (instancetype)initWithObject:(id)obj;</span><br><span class="line">@property (nonatomic, copy) id obj;</span><br><span class="line">@property (nonatomic, assign, getter=isExecuting) BOOL executing;</span><br><span class="line">@property (nonatomic, assign, getter=isFinished) BOOL finished;</span><br><span class="line">@end</span><br><span class="line">@implementation TestStartOperation</span><br><span class="line">@synthesize executing = _executing;</span><br><span class="line">@synthesize finished = _finished;</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObject:(id)obj&#123;</span><br><span class="line">    if(self = [super init])&#123;</span><br><span class="line">        self.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    return  self;</span><br><span class="line">&#125;</span><br><span class="line">- (void)start&#123;</span><br><span class="line">    </span><br><span class="line">    //在任务开始前设置executing为YES，在此之前可能会进行一些初始化操作</span><br><span class="line">    self.executing = YES;</span><br><span class="line">    NSLog(@&quot;开始执行任务%@ thread===%@&quot;,self.obj,[NSThread currentThread]);</span><br><span class="line">    /*</span><br><span class="line">    需要在适当的位置判断外部是否调用了cancel方法</span><br><span class="line">    如果被cancel了需要正确的结束任务</span><br><span class="line">    */</span><br><span class="line">    if (self.isCancelled)</span><br><span class="line">    &#123;</span><br><span class="line">        //任务被取消正确结束前手动设置状态</span><br><span class="line">        self.executing = NO;</span><br><span class="line">        self.finished = YES;</span><br><span class="line">        return;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    NSString *str = @&quot;https://www.360.cn&quot;;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">    NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    __weak typeof(self) weakSelf = self;</span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">       // NSLog(@&quot;response==%@&quot;,response);</span><br><span class="line">        NSLog(@&quot;TASK完成:====%@ thread====%@&quot;,weakSelf.obj,[NSThread currentThread]);</span><br><span class="line">        //任务执行完成后手动设置状态</span><br><span class="line">        weakSelf.executing = NO;</span><br><span class="line">        weakSelf.finished = YES;</span><br><span class="line">    &#125;];</span><br><span class="line">    [task resume];</span><br><span class="line">&#125;</span><br><span class="line">- (void)setExecuting:(BOOL)executing</span><br><span class="line">&#123;</span><br><span class="line">    //手动调用KVO通知</span><br><span class="line">    [self willChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">    _executing = executing;</span><br><span class="line">    //调用KVO通知</span><br><span class="line">    [self didChangeValueForKey:@&quot;isExecuting&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isExecuting</span><br><span class="line">&#123;</span><br><span class="line">    return _executing;</span><br><span class="line">&#125;</span><br><span class="line">- (void)setFinished:(BOOL)finished</span><br><span class="line">&#123;</span><br><span class="line">    //手动调用KVO通知</span><br><span class="line">    [self willChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">    _finished = finished;</span><br><span class="line">    //调用KVO通知</span><br><span class="line">    [self didChangeValueForKey:@&quot;isFinished&quot;];</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isFinished</span><br><span class="line">&#123;</span><br><span class="line">    return _finished;</span><br><span class="line">&#125;</span><br><span class="line">- (BOOL)isAsynchronous</span><br><span class="line">&#123;</span><br><span class="line">    return YES;</span><br><span class="line">&#125;</span><br><span class="line">- (void)dealloc&#123;</span><br><span class="line">    NSLog(@&quot;Dealloc %@&quot;,self.obj);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>执行与结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">NSOperationQueue *queue4 = [[NSOperationQueue alloc] init];</span><br><span class="line">TestStartOperation *operation4 = [[TestStartOperation alloc] initWithObject:[NSString stringWithFormat:@&quot;我是任务4&quot;]];</span><br><span class="line">TestStartOperation *operation5 = [[TestStartOperation alloc] initWithObject:[NSString stringWithFormat:@&quot;我是任务5&quot;]];</span><br><span class="line">TestStartOperation *operation6 = [[TestStartOperation alloc] initWithObject:[NSString stringWithFormat:@&quot;我是任务6&quot;]];</span><br><span class="line">//设置任务依赖 </span><br><span class="line">[operation4 addDependency:operation5];</span><br><span class="line">[operation5 addDependency:operation6];</span><br><span class="line">[queue4 addOperation:operation4];</span><br><span class="line">[queue4 addOperation:operation5];</span><br><span class="line">[queue4 addOperation:operation6];</span><br><span class="line">/*打印</span><br><span class="line">开始执行任务我是任务6 thread===&lt;NSThread: 0x600002bb8480&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">TASK完成:====我是任务6 thread====&lt;NSThread: 0x600002bd4d80&gt;&#123;number = 8, name = (null)&#125;</span><br><span class="line">开始执行任务我是任务5 thread===&lt;NSThread: 0x600002bb0300&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">TASK完成:====我是任务5 thread====&lt;NSThread: 0x600002bb0300&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">开始执行任务我是任务4 thread===&lt;NSThread: 0x600002bfb080&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">TASK完成:====我是任务4 thread====&lt;NSThread: 0x600002bfb080&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">2021-06-22 17:57:56.436591+0800 Interview01-打印[15994:9172130] Dealloc 我是任务4</span><br><span class="line">2021-06-22 17:57:56.436690+0800 Interview01-打印[15994:9172130] Dealloc 我是任务5</span><br><span class="line">2021-06-22 17:57:56.436784+0800 Interview01-打印[15994:9172130] Dealloc 我是任务6</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>在这个例子中我们在任务请求完成后，手动设置其<code>self.executing</code>和<code>self.finished</code>状态，并且手动触发KVO，队列会监听任务的执行状态。由于我们设置了任务依赖，当任务6请求完成后才会执行任务5，任务5请求完成后 才会执行任务4。最后对各自任务进行移除队列并释放。其实这样也变相解决了上面重写<code>main</code>方法中无法解决的问题。</p>
<h3 id="二-实际应用"><a href="#二-实际应用" class="headerlink" title="二.实际应用"></a>二.实际应用</h3><p><img src="https://i.loli.net/2021/06/25/BFjIue9kngfc8qQ.jpg" alt="执行"></p>
<blockquote>
<p>多个请求完成后继续进行下一个请求的方法总结</p>
</blockquote>
<p>在我们的工作中经常会遇到这样的请求：一个请求依赖另一个请求的结果，或者多个请求一起发出然后再获取所有的结果后继续后续操作。根据这几种情况总结常用的方法：</p>
<h4 id="1-使用GCD的dispatch-group-t实现"><a href="#1-使用GCD的dispatch-group-t实现" class="headerlink" title="1. 使用GCD的dispatch_group_t实现"></a>1. 使用<code>GCD</code>的<code>dispatch_group_t</code>实现</h4><p>需求：请求顺序执行，执行完成后回调结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"> NSString *str = @&quot;https://www.360.cn&quot;;</span><br><span class="line"> NSURL *url = [NSURL URLWithString:str];</span><br><span class="line"> NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line"> NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">   </span><br><span class="line"> dispatch_group_t downloadGroup = dispatch_group_create();</span><br><span class="line"> for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">       dispatch_group_enter(downloadGroup);</span><br><span class="line">       NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">           </span><br><span class="line">          NSLog(@&quot;执行完请求=%d&quot;,i);</span><br><span class="line">          dispatch_group_leave(downloadGroup);</span><br><span class="line">       &#125;];</span><br><span class="line">       </span><br><span class="line">       [task resume];</span><br><span class="line">   &#125;</span><br><span class="line">   dispatch_group_notify(downloadGroup, dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       NSLog(@&quot;end&quot;);</span><br><span class="line">   &#125;);</span><br><span class="line">/*</span><br><span class="line">2021-06-22 18:37:56.786878+0800 Interview01-打印[17121:9352056] 请求结束：0</span><br><span class="line">2021-06-22 18:37:56.787770+0800 Interview01-打印[17121:9352057] 请求结束：1</span><br><span class="line">2021-06-22 18:37:56.788492+0800 Interview01-打印[17121:9352057] 请求结束：2</span><br><span class="line">2021-06-22 18:37:56.789148+0800 Interview01-打印[17121:9352057] 请求结束：3</span><br><span class="line">2021-06-22 18:37:56.789837+0800 Interview01-打印[17121:9352057] 请求结束：4</span><br><span class="line">2021-06-22 18:37:56.790433+0800 Interview01-打印[17121:9352059] 请求结束：5</span><br><span class="line">2021-06-22 18:37:56.791117+0800 Interview01-打印[17121:9352059] 请求结束：6</span><br><span class="line">2021-06-22 18:37:56.791860+0800 Interview01-打印[17121:9352059] 请求结束：7</span><br><span class="line">2021-06-22 18:37:56.792614+0800 Interview01-打印[17121:9352059] 请求结束：8</span><br><span class="line">2021-06-22 18:37:56.793201+0800 Interview01-打印[17121:9352059] 请求结束：9</span><br><span class="line">2021-06-22 18:37:56.804529+0800 Interview01-打印[17121:9351753] end*/</span><br></pre></td></tr></table></figure>
<p>主要方法：</p>
<ul>
<li><code>dispatch_group_t downloadGroup = dispatch_group_create();</code>创建队列组</li>
<li><code>dispatch_group_enter(downloadGroup);</code> 每次执行请求前调用</li>
<li><code>dispatch_group_leave(downloadGroup);</code> 请求完成后调用离开方法</li>
<li><code>dispatch_group_notify()</code> 所有请求完成后回调block</li>
<li>对于enter和leave必须配合使用，有几次enter就要有几次leave</li>
</ul>
<h4 id="2-GCD信号量dispatch-semaphore-t"><a href="#2-GCD信号量dispatch-semaphore-t" class="headerlink" title="2. GCD信号量dispatch_semaphore_t"></a>2. <code>GCD</code>信号量<code>dispatch_semaphore_t</code></h4><h5 id="1-需求：顺序执行多个请求，都执行完成后回调给end"><a href="#1-需求：顺序执行多个请求，都执行完成后回调给end" class="headerlink" title="(1).需求：顺序执行多个请求，都执行完成后回调给end"></a>(1).需求：顺序执行多个请求，都执行完成后回调给end</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;https://www.360.cn&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">       </span><br><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">   </span><br><span class="line">for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">      </span><br><span class="line">     NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">           </span><br><span class="line">           NSLog(@&quot;请求结束：%d&quot;,i);</span><br><span class="line">           dispatch_semaphore_signal(sem);</span><br><span class="line">     &#125;];</span><br><span class="line">     [task resume];</span><br><span class="line">     dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">&#125;</span><br><span class="line">   dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">       NSLog(@&quot;end&quot;);</span><br><span class="line">   &#125;);</span><br></pre></td></tr></table></figure>
<p>主要方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line">dispatch_semaphore_signal(sem);</span><br><span class="line">dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br></pre></td></tr></table></figure>
<p><code>dispatch_semaphore</code>信号量为基于计数器的一种多线程同步机制,<code>dispatch_semaphore_signal(sem);</code>表示为计数+1操作，<code>dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</code> 信号量-1，遇到<code>dispatch_semaphore_wait</code>如果信号量的值小于0,就一直阻塞线程,不执行后面的所有程序,直到信号量大于等于0;当第一个for循环执行后<code>dispatch_semaphore_wait</code>堵塞线程，直到执行到<code>dispatch_semaphore_signal</code>后继续下一个for循环进行请求，以此类推完成顺序请求。</p>
<h5 id="2-需求：多个请求同时进行，都执行完成后回调给end"><a href="#2-需求：多个请求同时进行，都执行完成后回调给end" class="headerlink" title="(2).需求：多个请求同时进行，都执行完成后回调给end"></a>(2).需求：多个请求同时进行，都执行完成后回调给end</h5><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">NSString *str = @&quot;https://www.360.cn&quot;;</span><br><span class="line">NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">       </span><br><span class="line"> dispatch_semaphore_t sem = dispatch_semaphore_create(0);</span><br><span class="line"> __block int count = 0;</span><br><span class="line"> for (int i=0; i&lt;10; i++) &#123;</span><br><span class="line">           </span><br><span class="line">      NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">               </span><br><span class="line">        NSLog(@&quot;%d---%d&quot;,i,i);</span><br><span class="line">        count++;</span><br><span class="line">        if (count==10) &#123;</span><br><span class="line">            dispatch_semaphore_signal(sem);</span><br><span class="line">            count = 0;</span><br><span class="line">         &#125;</span><br><span class="line">       &#125;];</span><br><span class="line">           </span><br><span class="line">       [task resume];</span><br><span class="line">   &#125;</span><br><span class="line">   dispatch_semaphore_wait(sem, DISPATCH_TIME_FOREVER);</span><br><span class="line">       </span><br><span class="line">   dispatch_async(dispatch_get_main_queue(), ^&#123;</span><br><span class="line">        NSLog(@&quot;end&quot;);</span><br><span class="line">   &#125;);</span><br><span class="line">/*</span><br><span class="line">2021-06-23 09:47:49.723576+0800 Interview01-打印[21740:9823752] 请求完成：0</span><br><span class="line">2021-06-23 09:47:49.741118+0800 Interview01-打印[21740:9823751] 请求完成：1</span><br><span class="line">2021-06-23 09:47:49.756781+0800 Interview01-打印[21740:9823752] 请求完成：3</span><br><span class="line">2021-06-23 09:47:49.765250+0800 Interview01-打印[21740:9823752] 请求完成：2</span><br><span class="line">2021-06-23 09:47:49.773008+0800 Interview01-打印[21740:9823756] 请求完成：4</span><br><span class="line">2021-06-23 09:47:49.797809+0800 Interview01-打印[21740:9823751] 请求完成：5</span><br><span class="line">2021-06-23 09:47:49.801775+0800 Interview01-打印[21740:9823751] 请求完成：6</span><br><span class="line">2021-06-23 09:47:49.805542+0800 Interview01-打印[21740:9823751] 请求完成：7</span><br><span class="line">2021-06-23 09:47:49.814714+0800 Interview01-打印[21740:9823751] 请求完成：8</span><br><span class="line">2021-06-23 09:47:49.850517+0800 Interview01-打印[21740:9823753] 请求完成：9</span><br><span class="line">2021-06-23 09:47:49.864394+0800 Interview01-打印[21740:9823591] end</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>这个也比较好理解，for循环运行后堵塞当前线程（当前是主线程，你也可以把这段代码放入子线程中去执行），当10个请求全部完成后发送信号，继续下面的流程。</p>
<h4 id="3-使用NSOperation与GCD结合使用"><a href="#3-使用NSOperation与GCD结合使用" class="headerlink" title="3. 使用NSOperation与GCD结合使用"></a>3. 使用<code>NSOperation</code>与<code>GCD</code>结合使用</h4><p>需求：两个网络请求，第一个依赖第二个的回调结果</p>
<p>通过自定义<code>operation</code>实现，我们重写其main方法</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">@interface CustomOperation : NSOperation</span><br><span class="line">@property (nonatomic, copy) id obj;</span><br><span class="line">- (instancetype)initWithObject:(id)obj;</span><br><span class="line">@end</span><br><span class="line">@implementation CustomOperation</span><br><span class="line"></span><br><span class="line">- (instancetype)initWithObject:(id)obj&#123;</span><br><span class="line">    if(self = [super init])&#123;</span><br><span class="line">        self.obj = obj;</span><br><span class="line">    &#125;</span><br><span class="line">    return  self;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">- (void)main&#123;</span><br><span class="line">    </span><br><span class="line">    //创建信号量并设置计数默认为0</span><br><span class="line">    dispatch_semaphore_t sema = dispatch_semaphore_create(0);</span><br><span class="line">    NSLog(@&quot;开始执行任务%@&quot;,self.obj);</span><br><span class="line">    NSString *str = @&quot;https://www.360.cn&quot;;</span><br><span class="line">    NSURL *url = [NSURL URLWithString:str];</span><br><span class="line">    NSURLRequest *request = [NSURLRequest requestWithURL:url];</span><br><span class="line">    NSURLSession *session = [NSURLSession sharedSession];</span><br><span class="line">    </span><br><span class="line">    NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler:^(NSData * _Nullable data, NSURLResponse * _Nullable response, NSError * _Nullable error) &#123;</span><br><span class="line">        NSLog(@&quot;TASK完成:====%@ thread====%@&quot;,self.obj,[NSThread currentThread]);</span><br><span class="line">        //请求成功 计数+1操作</span><br><span class="line">        dispatch_semaphore_signal(sema);</span><br><span class="line">    &#125;];</span><br><span class="line"></span><br><span class="line">    [task resume];</span><br><span class="line">    </span><br><span class="line">    //若计数为0则一直等待</span><br><span class="line">    dispatch_semaphore_wait(sema, DISPATCH_TIME_FOREVER);</span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>调用与结果</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"> NSOperationQueue *queue3 = [[NSOperationQueue alloc] init];</span><br><span class="line">    [queue3 setMaxConcurrentOperationCount:2];</span><br><span class="line">    CustomOperation *operation0 = [[CustomOperation alloc] initWithObject:@&quot;我是任务0&quot;];</span><br><span class="line">    CustomOperation *operation1 = [[CustomOperation alloc] initWithObject:@&quot;我是任务1&quot;];</span><br><span class="line">    CustomOperation *operation2 = [[CustomOperation alloc] initWithObject:@&quot;我是任务2&quot;];</span><br><span class="line">    CustomOperation *operation3 = [[CustomOperation alloc] initWithObject:@&quot;我是任务3&quot;];</span><br><span class="line"></span><br><span class="line">    [operation0 addDependency:operation1];</span><br><span class="line">    [operation1 addDependency:operation2];</span><br><span class="line">    [operation2 addDependency:operation3];</span><br><span class="line"></span><br><span class="line">    [queue3 addOperation:operation0];</span><br><span class="line">    [queue3 addOperation:operation1];</span><br><span class="line">    [queue3 addOperation:operation2];</span><br><span class="line">    [queue3 addOperation:operation3];</span><br><span class="line">/**打印结果</span><br><span class="line">开始执行任务我是任务3</span><br><span class="line">TASK完成:====我是任务3 thread====&lt;NSThread: 0x6000039c3340&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">开始执行任务我是任务2</span><br><span class="line">TASK完成:====我是任务2 thread====&lt;NSThread: 0x6000039ece80&gt;&#123;number = 7, name = (null)&#125;</span><br><span class="line">开始执行任务我是任务1</span><br><span class="line">TASK完成:====我是任务1 thread====&lt;NSThread: 0x6000039c3340&gt;&#123;number = 5, name = (null)&#125;</span><br><span class="line">开始执行任务我是任务0</span><br><span class="line">TASK完成:====我是任务0 thread====&lt;NSThread: 0x6000039c3d00&gt;&#123;number = 6, name = (null)&#125;</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<ul>
<li>设置任务依赖并且添加到队列后是可以满足我们的需求</li>
<li>由于任务内部是异步回调，可以看到任务内部的执行还是依赖于<code>dispatch_semaphore_t</code>来实现的</li>
<li>也可以通过重写<code>start</code>方法实现，在上面章节我们已经介绍过了，这里不再赘述。</li>
</ul>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h3><p>本文的篇幅有点长了，但是还有一些内容没有覆盖到，比如iOS中常用的线程锁、<code>NSOperationQueue</code>的暂停与取消等，我们会在后面的文章中逐步完善补充。</p>
<blockquote>
<p>由于作者水平有限，难免出现纰漏，如有问题还请不吝赐教。</p>
</blockquote>
<p>参考资料：</p>
<p><a target="_blank" rel="noopener" href="https://developer.apple.com/library/archive/documentation/General/Conceptual/ConcurrencyProgrammingGuide/OperationObjects/OperationObjects.html">苹果官方——并发编程指南：Operation Queues</a></p>
<p><a target="_blank" rel="noopener" href="https://blog.csdn.net/liuyang11908/article/details/70757534">iOS GCD之dispatch_semaphore(信号量)</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenxming.github.io/2022/06/16/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8B%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" data-id="cllnf859x000816ex8ephhynr" data-title="iOS-多线程使用总结" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/07/18/%E4%BB%8EVuex%E5%88%B0Pinia/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          从Vuex到Pinia
        
      </div>
    </a>
  
  
    <a href="/2022/05/17/%E5%89%8D%E7%AB%AFVue%E5%85%A5%E9%97%A8%E6%80%BB%E7%BB%93/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">前端Vue入门总结</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/05/26/%E6%B5%85%E8%B0%88Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">浅谈Vue3响应式原理与源码解读</a>
          </li>
        
          <li>
            <a href="/2023/04/01/setState%E4%B8%8EuseState%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E9%A1%B9/">setState与useState使用注意项</a>
          </li>
        
          <li>
            <a href="/2023/02/06/%E4%BD%BF%E7%94%A8useReducer%20+%20useContext%20%E4%BB%A3%E6%9B%BF%20react-redux/">使用useReducer + useContext 代替 react-redux</a>
          </li>
        
          <li>
            <a href="/2022/11/15/GitHub%20Actions%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%20Vue%20%E9%A1%B9%E7%9B%AE/">GitHub Actions 自动部署前端 Vue 项目</a>
          </li>
        
          <li>
            <a href="/2022/09/15/Vue3.2%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/">Vue3.2语法糖使用总结</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 chenXming<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>