<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  
  <title>Vue3.2语法糖使用总结 | chenXming的个人技术网站</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
  <meta name="description" content="一. 概述在Vue2时期，组件里定义的各类变量、方法、计算属性等是分别存放到data、methods、computed等选项里，这样编写的代码不便于后期的查阅，查找一个业务逻辑需要在各个选项来回切换。vue3.0组合式APIsetup函数的推出就是为了解决这个问题，它让我们的逻辑关注点更加集中，语法也更加精简，但是当我们在使用vue3.0的语法就构建组件的时候，总是需要把外面定义的方法变量必须要r">
<meta property="og:type" content="article">
<meta property="og:title" content="Vue3.2语法糖使用总结">
<meta property="og:url" content="https://chenxming.github.io/2022/09/15/Vue3.2%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/index.html">
<meta property="og:site_name" content="chenXming的个人技术网站">
<meta property="og:description" content="一. 概述在Vue2时期，组件里定义的各类变量、方法、计算属性等是分别存放到data、methods、computed等选项里，这样编写的代码不便于后期的查阅，查找一个业务逻辑需要在各个选项来回切换。vue3.0组合式APIsetup函数的推出就是为了解决这个问题，它让我们的逻辑关注点更加集中，语法也更加精简，但是当我们在使用vue3.0的语法就构建组件的时候，总是需要把外面定义的方法变量必须要r">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-09-15T12:46:25.000Z">
<meta property="article:modified_time" content="2023-08-23T07:34:13.071Z">
<meta property="article:author" content="chenXming">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="chenXming的个人技术网站" type="application/atom+xml">
  
  
    <link rel="shortcut icon" href="/favicon.png">
  
  
    
<link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/typeface-source-code-pro@0.0.71/index.min.css">

  
  
<link rel="stylesheet" href="/css/style.css">

  
    
<link rel="stylesheet" href="/fancybox/jquery.fancybox.min.css">

  
  
<meta name="generator" content="Hexo 6.3.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">chenXming的个人技术网站</a>
      </h1>
      
        <h2 id="subtitle-wrap">
          <a href="/" id="subtitle">技术博客</a>
        </h2>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"><span class="fa fa-bars"></span></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        
          <a class="nav-icon" href="/atom.xml" title="RSS 订阅"><span class="fa fa-rss"></span></a>
        
        <a class="nav-icon nav-search-btn" title="搜索"><span class="fa fa-search"></span></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="搜索"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="https://chenxming.github.io"></form>
      </div>
    </div>
  </div>
</header>

      <div class="outer">
        <section id="main"><article id="post-Vue3.2语法糖使用总结" class="h-entry article article-type-post" itemprop="blogPost" itemscope itemtype="https://schema.org/BlogPosting">
  <div class="article-meta">
    <a href="/2022/09/15/Vue3.2%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" class="article-date">
  <time class="dt-published" datetime="2022-09-15T12:46:25.000Z" itemprop="datePublished">2022-09-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="p-name article-title" itemprop="headline name">
      Vue3.2语法糖使用总结
    </h1>
  

      </header>
    
    <div class="e-content article-entry" itemprop="articleBody">
      
        <h3 id="一-概述"><a href="#一-概述" class="headerlink" title="一. 概述"></a>一. 概述</h3><p>在<code>Vue2</code>时期，组件里定义的各类变量、方法、计算属性等是分别存放到<code>data</code>、<code>methods</code>、<code>computed</code>等选项里，这样编写的代码不便于后期的查阅，查找一个业务逻辑需要在各个选项来回切换。<code>vue3.0</code>组合式API<code>setup</code>函数的推出就是为了解决这个问题，它让我们的逻辑关注点更加集中，语法也更加精简，但是当我们在使用<code>vue3.0</code>的语法就构建组件的时候，总是需要把外面定义的方法变量必须要return出去才能在<code>&lt;template&gt;</code>，比较麻烦一些. <code>vue3.2</code>语法糖的出现以及一些新增的API，让我们的代码进一步简化。</p>
<h4 id="什么是语法糖？"><a href="#什么是语法糖？" class="headerlink" title="什么是语法糖？"></a>什么是语法糖？</h4><p><strong>语法糖</strong>（英语：Syntactic sugar）是由英国计算机科学家<a target="_blank" rel="noopener" href="https://zh.m.wikipedia.org/wiki/%E5%BD%BC%E5%BE%97%C2%B7%E5%85%B0%E4%B8%81">彼得·兰丁</a>发明的一个术语，指计算机语言中添加的某种语法，这种语法对语言的功能没有影响，但是更方便程序员使用。语法糖让程序更加简洁，有更高的可读性。</p>
<h4 id="Vue3-2语法糖"><a href="#Vue3-2语法糖" class="headerlink" title="Vue3.2语法糖"></a><code>Vue3.2</code>语法糖</h4><p>来看下<code>vue3.0</code>与<code>vue3.2</code>的单文件组件（SFC，即.vue 文件）的结构对比</p>
<ul>
<li><code>vue3.0</code>组件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">    components: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    props: &#123;</span><br><span class="line">    &#125;,</span><br><span class="line">    setup () &#123;</span><br><span class="line">        return &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
<li><code>vue3.2</code>组件<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;MyTestVue :title=&quot;title&quot; @click=&quot;changeTitle&quot; /&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import MyTestVue from &#x27;./MyTest.vue&#x27;;</span><br><span class="line">import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">const title = ref(&#x27;测试一下&#x27;)</span><br><span class="line">const changeTitle = () =&gt; &#123;</span><br><span class="line">    title.value = &#x27;Hello,World&#x27;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li>
</ul>
<ol>
<li><p>对比<code>vue3.0</code> 与<code>vue3.2</code>版本的组件模板，最主要的变化是3.2中没有了<code>setup</code>函数，而是把它放在了script标签中。</p>
</li>
<li><p>我们定义的属性和方法也不用在return中返回，直接就可以用在模板语法中<br> …</p>
<p> 这些是直观的变化，接下来我们学习具体的用法。</p>
</li>
</ol>
<h3 id="二-使用介绍"><a href="#二-使用介绍" class="headerlink" title="二.使用介绍"></a>二.使用介绍</h3><h4 id="1-组件注册"><a href="#1-组件注册" class="headerlink" title="1.组件注册"></a>1.组件注册</h4><p><code>vue3.0</code>中使用组件，需要使用 components 选项来显式注册：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">import ComponentA from &#x27;./ComponentA.js&#x27;</span><br><span class="line"></span><br><span class="line">export default &#123;</span><br><span class="line">  components: &#123;</span><br><span class="line">    ComponentA</span><br><span class="line">  &#125;,</span><br><span class="line">  setup() &#123;</span><br><span class="line">    // ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><code>vue3.2</code> <code>&lt;script setup&gt;</code> 的单文件组件中，导入的组件可以直接在模板中使用，组件会自动注册，并且无需指定当前组件的名字，它会自动以文件名为主，也就是不用再写name属性了。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import ComponentA from &#x27;./ComponentA.vue&#x27;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;ComponentA /&gt;</span><br><span class="line">&lt;/template&gt;</span><br></pre></td></tr></table></figure>

<h4 id="2-Props-声明"><a href="#2-Props-声明" class="headerlink" title="2.Props 声明"></a>2.Props 声明</h4><p>在<code>vue3.0</code>中，<code>prop</code>可以使用<code>props</code>选项来声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  props: [&#x27;foo&#x27;],</span><br><span class="line">  // 或者用这种方式指类型与默认值</span><br><span class="line">  // props: &#123;</span><br><span class="line">  //   foo:&#123;</span><br><span class="line">  //     type: String,</span><br><span class="line">  //     default: &#x27;&#x27;</span><br><span class="line">  //   &#125;,</span><br><span class="line">  // &#125;,</span><br><span class="line">  setup(props) &#123;</span><br><span class="line">    // setup() 接收 props 作为第一个参数</span><br><span class="line">    console.log(props.foo)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>vue3.2</code>组件中，<code>props</code>可以使用<code>defineProps()</code>宏来声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">const props = defineProps([&#x27;foo&#x27;])</span><br><span class="line">// 或者</span><br><span class="line">const propsOther = defineProps(&#123;</span><br><span class="line">  title: String,</span><br><span class="line">  likes: Number</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.log(props.foo)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>注意事项：所有的 props 都遵循着单向绑定原则，props 因父组件的更新而变化，自然地将新的状态向下流往子组件，而不会逆向传递，这意味着你不应该在子组件中去更改一个 prop。</p>
</blockquote>
<h4 id="3-计算属性"><a href="#3-计算属性" class="headerlink" title="3.计算属性"></a>3.计算属性</h4><p>我们一般使用计算属性来描述依赖响应式状态的复杂逻辑。说白了就是这个计算属性的值依赖于其他响应式属性的值，依赖的属性发生变化，那么这个计算属性的值就会进行重新计算。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, computed &#125; from &#x27;vue&#x27;</span><br><span class="line"></span><br><span class="line">const firstName = ref(&#x27;John&#x27;)</span><br><span class="line">const lastName = ref(&#x27;Doe&#x27;)</span><br><span class="line"></span><br><span class="line">const fullName = computed(&#123;</span><br><span class="line">  // getter</span><br><span class="line">  get() &#123;</span><br><span class="line">    return firstName.value + &#x27; &#x27; + lastName.value</span><br><span class="line">  &#125;,</span><br><span class="line">  // setter</span><br><span class="line">  set(newValue) &#123;</span><br><span class="line">    // 注意：我们这里使用的是解构赋值语法</span><br><span class="line">    [firstName.value, lastName.value] = newValue.split(&#x27; &#x27;)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>当调用<code>fullName.value = &#39;John Doe&#39;</code>时，<code>setter</code>会被调用，而<code>firstName</code> 和 <code>lastName</code>会被更新，在<code>vue3.2</code>中我们可以直接在<code>&lt;template&gt;</code>标签中使用它，不在需要return返回。</p>
<blockquote>
<ul>
<li>不要在计算函数中做异步请求或者更改 DOM！</li>
<li>一个计算属性仅会在其响应式依赖更新时才重新计算，如果他依赖的是个非响应式的依赖，及时其值发生变化，计算属性也不会更新。</li>
<li>相比于方法而言，计算属性值会基于其响应式依赖被缓存，一个计算属性仅会在其响应式依赖更新时才重新计算</li>
</ul>
</blockquote>
<h4 id="4-watch"><a href="#4-watch" class="headerlink" title="4. watch"></a>4. watch</h4><p>在组合式API中，我们可以使用<code>watch</code>函数在每次响应式状态发生变化时触发回调函数,<code>watch</code>的第一个参数可以是不同形式的“数据源”：它可以是一个<code> ref</code>(包括计算属性)、一个响应式对象、一个 <code>getter</code> 函数、或多个数据源组成的数组：<br><code>watch()</code>是懒执行的：仅当数据源变化时，才会执行回调，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref,watch &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">    title: String,</span><br><span class="line">    itemList: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default: () =&gt; [&#123;</span><br><span class="line">            text: &#x27;title&#x27;,</span><br><span class="line">            value: 0</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">watch(() =&gt; props.itemList.length,(newValue,oldValue) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;newValue===&#x27;,newValue);</span><br><span class="line">    console.log(&#x27;oldValue===&#x27;,oldValue);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>这里监听<code>props.itemList.length</code>，当传入的<code>itemList</code>数量发生变化时，后面的回调方法会被调用。当然<code>wacth()</code>还有第三个可选参数：<code>否开启深监听(deep)</code>, 如果这里这样写:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref,watch &#125; from &#x27;vue&#x27;;</span><br><span class="line">...</span><br><span class="line">watch(() =&gt; props.itemList,(newValue,oldValue) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;newValue===&#x27;,newValue);</span><br><span class="line">    console.log(&#x27;oldValue===&#x27;,oldValue);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p>当传入的<code>itemList</code>数量发生改变时，回调函数不会触发，正确的写法是加上其第三个参数<code>deep:true</code></p>
</blockquote>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref,watch &#125; from &#x27;vue&#x27;;</span><br><span class="line">...</span><br><span class="line">watch(() =&gt; props.itemList,(newValue,oldValue) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;newValue===&#x27;,newValue);</span><br><span class="line">    console.log(&#x27;oldValue===&#x27;,oldValue);</span><br><span class="line">&#125;,&#123;deep:true&#125;)</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>watch</code>也可以同时监听多个属性：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref,watch &#125; from &#x27;vue&#x27;;</span><br><span class="line"></span><br><span class="line">const props = defineProps(&#123;</span><br><span class="line">    title: String,</span><br><span class="line">    itemList: &#123;</span><br><span class="line">        type: Array,</span><br><span class="line">        default: () =&gt; [&#123;</span><br><span class="line">            text: &#x27;title&#x27;,</span><br><span class="line">            value: 0</span><br><span class="line">        &#125;]</span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">// 同时监听多个属性</span><br><span class="line">watch(() =&gt; [props.itemList,props.title],(newValue,oldValue) =&gt; &#123;</span><br><span class="line">    console.log(&#x27;newValue===&#x27;,newValue);</span><br><span class="line">    console.log(&#x27;oldValue===&#x27;,oldValue);</span><br><span class="line">&#125;,&#123;deep:true&#125;)</span><br><span class="line">  </span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="5-watchEffect"><a href="#5-watchEffect" class="headerlink" title="5. watchEffect()"></a>5. <code>watchEffect()</code></h4><p>与<code>watch()</code>的懒执行不同的是，<code>watchEffect()</code>会立即执行一遍回调函数，如果这时函数产生了副作用，<code>Vue</code>会自动追踪副作用的依赖关系，自动分析出响应源。上面的例子可以重写为：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  ...</span><br><span class="line">watchEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;itemList===&#x27;,props.itemList.length);</span><br><span class="line">    console.log(&#x27;title===&#x27;,props.title);</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt;  </span><br></pre></td></tr></table></figure>
<p>这个例子中，回调会立即执行。在执行期间，它会自动追踪<code>props.itemList.length</code>作为依赖（和计算属性的行为类似）。每当传入的<code>itemList.length</code>变化时，回调会再次执行。</p>
<p>如果要清除<code>watchEffect()</code>的的监听，只需要显示的调用<code>watchEffect()</code>的返回函数就可以了，例如：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">  ...</span><br><span class="line">const stopEffect = watchEffect(() =&gt; &#123;</span><br><span class="line">    console.log(&#x27;itemList===&#x27;,props.itemList.length);</span><br><span class="line">    console.log(&#x27;title===&#x27;,props.title);</span><br><span class="line">&#125;)</span><br><span class="line">stopEffect()</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<blockquote>
<p>watch 只追踪明确侦听的数据源。它不会追踪任何在回调中访问到的东西。另外，仅在数据源确实改变时才会触发回调。我们能更加精确地控制回调函数的触发时机。<br>watchEffect，则会在副作用发生期间追踪依赖。它会在同步执行过程中，自动追踪所有能访问到的响应式属性。</p>
</blockquote>
<h4 id="6-组件的事件调用"><a href="#6-组件的事件调用" class="headerlink" title="6.组件的事件调用"></a>6.组件的事件调用</h4><h5 id="6-1-子组件调用父组件的方法"><a href="#6-1-子组件调用父组件的方法" class="headerlink" title="6.1 子组件调用父组件的方法"></a>6.1 子组件调用父组件的方法</h5><p><code>vue3.0</code>中如果我们的子组件触发父组件的方法，我们的做法:</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">子组件</span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  emits: [&#x27;inFocus&#x27;, &#x27;submit&#x27;],</span><br><span class="line">  setup(props, ctx) &#123;</span><br><span class="line">    ctx.emit(&#x27;submit&#x27;,params)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">// 或者将可以将emit解构使用</span><br><span class="line">export default &#123;</span><br><span class="line">    setup(props,&#123;emit&#125;) &#123;</span><br><span class="line">    emit(&#x27;submit&#x27;,params)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Children @submit=&quot;submitHandel&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script&gt;</span><br><span class="line">export default &#123;</span><br><span class="line">  name: &#x27;TodoItem&#x27;,</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    const submitHandel = () =&gt; &#123;</span><br><span class="line">      console.log(&#x27;子组件调用了父组件的submitHandel方法&#x27;);</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">      submitHandel,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><code>vue3.2</code>语法糖中,子组件要触发的事件需要显式地通过 <code>defineEmits()</code> 宏来声明</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const emit = defineEmits([&#x27;inFocus&#x27;, &#x27;submit&#x27;])</span><br><span class="line"></span><br><span class="line">function buttonClick(parmas) &#123;</span><br><span class="line">  emit(&#x27;submit&#x27;, parmas)</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">    &lt;Children @submit=&quot;submitHandel&quot;/&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line"></span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  const submitHandel = () =&gt; &#123;</span><br><span class="line">    console.log(&#x27;子组件调用了父组件的submitHandel方法&#x27;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h5 id="6-2-父组件调用子组件的方法或是属性"><a href="#6-2-父组件调用子组件的方法或是属性" class="headerlink" title="6.2 父组件调用子组件的方法或是属性"></a>6.2 父组件调用子组件的方法或是属性</h5><p><code>vue3.0</code>中如果父组件触发子组件的方法或是属性，直接在return函数中返回就可以，数据都是默认隐式暴露给父组件的。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&lt;script&gt;</span><br><span class="line">// 子组件</span><br><span class="line">setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">  const isShow = ref(false)</span><br><span class="line">  // 父组件调用这个方法</span><br><span class="line">  const showSubComponent = () =&gt; &#123;</span><br><span class="line">    isShow.value = !isShow.value</span><br><span class="line">  &#125;</span><br><span class="line">  return &#123;</span><br><span class="line">      // return 返回</span><br><span class="line">      showSubComponent,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>父组件中通过<code>ref</code>获取到子组件，并对子组件暴露的方法进行访问</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;todo-list&quot;&gt;</span><br><span class="line">    &lt;TodoItemVue :itemList=&quot;itemList&quot; @clickItemHandel=&quot;clickItemHandel&quot; ref=&quot;todoItemVueRef&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">  export default &#123;</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    //获取子组件ref</span><br><span class="line">    const todoItemVueRef = ref(null)</span><br><span class="line">    // 调用子组件的方法</span><br><span class="line">    const callItemFuncHandel = () =&gt; &#123;</span><br><span class="line">        todoItemVueRef.value.showSubComponent()</span><br><span class="line">    &#125;</span><br><span class="line">    return &#123;</span><br><span class="line">     todoItemVueRef</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p><code>vue3.2</code>语法中，父组件的调用方式相同，子组件通过<code>defineExpose()</code>将方法或是属性暴露出去</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">子组件</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">const isShow = ref(false)</span><br><span class="line">// 父组件调用这个方法</span><br><span class="line">const showSubComponent = () =&gt; &#123;</span><br><span class="line">    isShow.value = !isShow.value</span><br><span class="line">&#125;</span><br><span class="line">// 通过defineExpose将方法暴露出去</span><br><span class="line">defineExpose(&#123;</span><br><span class="line">    showSubComponent</span><br><span class="line">&#125;)</span><br><span class="line">&lt;/script&gt; </span><br><span class="line">父组件</span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;todo-list&quot;&gt;</span><br><span class="line">    &lt;TodoItemVue :itemList=&quot;itemList&quot; @clickItemHandel=&quot;clickItemHandel&quot; ref=&quot;todoItemVueRef&quot; /&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">  import &#123; ref &#125; from &#x27;vue&#x27;;</span><br><span class="line">  //获取子组件ref</span><br><span class="line">  const todoItemVueRef = ref(null)</span><br><span class="line">  // 调用子组件的方法</span><br><span class="line">  const callItemFuncHandel = () =&gt; &#123;</span><br><span class="line">      todoItemVueRef.value.showSubComponent()</span><br><span class="line">  &#125;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>
<h4 id="7-Vuex的使用"><a href="#7-Vuex的使用" class="headerlink" title="7.Vuex的使用"></a>7.Vuex的使用</h4><p>在<code>vue3.0</code>与<code>vue3.2</code>中创建<code>Vuex</code>没有区别，只不过在<code>&lt;template&gt;</code>模板中使用Vuex的<code>store</code>有细微差别。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; createStore &#125; <span class="keyword">from</span> <span class="string">&#x27;vuex&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="variable constant_">ADD_ITEM_LIST</span>, <span class="variable constant_">REDUCE_ITEM_LIST</span>, <span class="variable constant_">CHANGE_ITEM_LIST_ASYNC</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./constants&#x27;</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="title function_">createStore</span>(&#123;</span><br><span class="line">  <span class="attr">state</span>: &#123;</span><br><span class="line">    <span class="attr">itemList</span>: [</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;Learn JavaScript&#x27;</span>, <span class="attr">done</span>: <span class="literal">true</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;Learn Vue&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">      &#123; <span class="attr">text</span>: <span class="string">&#x27;Build something awesome&#x27;</span>, <span class="attr">done</span>: <span class="literal">false</span> &#125;,</span><br><span class="line">    ],</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">getters</span>: &#123;</span><br><span class="line">    <span class="attr">doneItemList</span>: <span class="function">(<span class="params">state</span>) =&gt;</span> state.<span class="property">itemList</span>.<span class="title function_">filter</span>(<span class="function">(<span class="params">todo</span>) =&gt;</span> todo.<span class="property">done</span>),</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">mutations</span>: &#123;</span><br><span class="line">    <span class="comment">// 使用ES2015风格的计算属性命名功能 来使用一个常量作为函数名</span></span><br><span class="line">    [<span class="variable constant_">ADD_ITEM_LIST</span>](state, item) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;增加数据&#x27;</span>, item);</span><br><span class="line">      state.<span class="property">itemList</span>.<span class="title function_">push</span>(item);</span><br><span class="line">    &#125;,</span><br><span class="line">    [<span class="variable constant_">REDUCE_ITEM_LIST</span>](state) &#123;</span><br><span class="line">      <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;减少数据&#x27;</span>);</span><br><span class="line">      state.<span class="property">itemList</span>.<span class="title function_">pop</span>();</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">actions</span>: &#123;</span><br><span class="line">    [<span class="variable constant_">CHANGE_ITEM_LIST_ASYNC</span>](&#123; commit, state &#125;, todoItem) &#123;</span><br><span class="line">      <span class="comment">/// 模拟网络请求</span></span><br><span class="line">      <span class="built_in">setTimeout</span>(<span class="function">() =&gt;</span> &#123;</span><br><span class="line">        <span class="title function_">commit</span>(<span class="variable constant_">ADD_ITEM_LIST</span>, todoItem);</span><br><span class="line">        <span class="variable language_">console</span>.<span class="title function_">log</span>(<span class="string">&#x27;state===&#x27;</span>, state);</span><br><span class="line">      &#125;, <span class="number">1000</span>);</span><br><span class="line">    &#125;,</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">modules</span>: &#123;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>

<p>在<code>vue3.0</code>中我们一般在return中对<code>store.state</code>进行解构,然后可以直接在<code>&lt;template&gt;</code>中使用<code>state</code>中的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;todo-item&quot;&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li v-for=&quot;(item,index) in itemList&quot; :key=&quot;index&quot; class=&quot;todos&quot; @click=&quot;clickItem(index)&quot;&gt;</span><br><span class="line">        &#123;&#123; item.text &#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">  export default &#123;</span><br><span class="line">  name: &#x27;TodoItem&#x27;,</span><br><span class="line">  setup(props, &#123; emit &#125;) &#123;</span><br><span class="line">    return &#123;</span><br><span class="line">      // 对store.state进行解构</span><br><span class="line">      ...store.state,</span><br><span class="line">      clickItem,</span><br><span class="line">      count,</span><br><span class="line">      isShow,</span><br><span class="line">      showSubComponent,</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<p><code>vue3.2</code>中没有了return，需要我们显示的获取要使用的<code>stare</code>的值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;div class=&quot;todo-item&quot;&gt;</span><br><span class="line">    &lt;ol&gt;</span><br><span class="line">      &lt;li v-for=&quot;(item,index) in itemList&quot; :key=&quot;index&quot; class=&quot;todos&quot; @click=&quot;clickItem(index)&quot;&gt;</span><br><span class="line">        &#123;&#123; item.text &#125;&#125;</span><br><span class="line">      &lt;/li&gt;</span><br><span class="line">    &lt;/ol&gt;</span><br><span class="line">  &lt;/div&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; useStore &#125; from &#x27;vuex&#x27;;</span><br><span class="line">const store = useStore()</span><br><span class="line">// 获取后在&lt;template&gt;中使用</span><br><span class="line">const itemList = store.state.itemList</span><br><span class="line">&lt;/script&gt;</span><br></pre></td></tr></table></figure>

<h4 id="8-中的-v-bind"><a href="#8-中的-v-bind" class="headerlink" title="8. &lt;style&gt;中的 v-bind"></a>8. <code>&lt;style&gt;</code>中的 v-bind</h4><p><code>&lt;style&gt;</code>中的 <code>v-bind</code>: 用于在 SFC <code>&lt;style&gt;</code> 标签中启用组件状态驱动的动态 CSS 值</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">&lt;script setup&gt;</span><br><span class="line">import &#123; ref, watchEffect &#125; from &#x27;vue&#x27;;</span><br><span class="line">const color = ref(&#x27;black&#x27;)</span><br><span class="line">const callChangeColorHandel = () =&gt; &#123;</span><br><span class="line">  if(color.value === &#x27;black&#x27;) &#123;</span><br><span class="line">    color.value = &#x27;red&#x27;</span><br><span class="line">  &#125;else &#123;</span><br><span class="line">    color.value = &#x27;black&#x27;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot; scoped&gt;</span><br><span class="line">.todo-list &#123;</span><br><span class="line">  color: v-bind(color);</span><br><span class="line">&#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure>

<p>触发<code>callChangeColorHandel</code> 函数，在<code>&lt;style&gt;</code>中的<code>v-bind</code>指令可以动态绑定的响应式状态。</p>
<h3 id="三-总结"><a href="#三-总结" class="headerlink" title="三. 总结"></a>三. 总结</h3><p>整体来说，setup语法糖的引入简化了使用<code>Composition API</code>时冗长的模板代码，也就是让代码更加简洁，可读性也更高。并且官方介绍<code>vue3.2</code>在界面渲染的速度以及内存的使用量上都进行了优化，本文只是对setup语法糖的常用方式进行了总结，更多<code>vue3.2</code>新特性可以去官方文档查看。</p>
<p>一些参考：</p>
<p><a target="_blank" rel="noopener" href="https://blog.vuejs.org/posts/vue-3.2.html">Vue3.2</a></p>
<p><a target="_blank" rel="noopener" href="https://vuex.vuejs.org/zh/#%E4%BB%80%E4%B9%88%E6%98%AF%22%E7%8A%B6%E6%80%81%E7%AE%A1%E7%90%86%E6%A8%A1%E5%BC%8F%22%EF%BC%9F">Vuex</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="https://chenxming.github.io/2022/09/15/Vue3.2%E8%AF%AD%E6%B3%95%E7%B3%96%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/" data-id="cllnfb8p100023fex8draej6s" data-title="Vue3.2语法糖使用总结" class="article-share-link"><span class="fa fa-share">分享</span></a>
      
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2022/11/15/GitHub%20Actions%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%20Vue%20%E9%A1%B9%E7%9B%AE/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">前一篇</strong>
      <div class="article-nav-title">
        
          GitHub Actions 自动部署前端 Vue 项目
        
      </div>
    </a>
  
  
    <a href="/2022/07/18/%E4%BB%8EVuex%E5%88%B0Pinia/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">后一篇</strong>
      <div class="article-nav-title">从Vuex到Pinia</div>
    </a>
  
</nav>

  
</article>


</section>
        
          <aside id="sidebar">
  
    

  
    

  
    
  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/08/">八月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/05/">五月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/04/">四月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2023/02/">二月 2023</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/11/">十一月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/09/">九月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/07/">七月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/06/">六月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/05/">五月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2022/03/">三月 2022</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/11/">十一月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/10/">十月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/09/">九月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/08/">八月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/05/">五月 2021</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2021/04/">四月 2021</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2023/08/23/%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%8F%91%E4%B8%80%E6%AC%BEChatGPT%20VSCode%E6%8F%92%E4%BB%B6/">从零开发一款ChatGPT VSCode插件</a>
          </li>
        
          <li>
            <a href="/2023/05/26/%E6%B5%85%E8%B0%88Vue3%E5%93%8D%E5%BA%94%E5%BC%8F%E5%8E%9F%E7%90%86%E4%B8%8E%E6%BA%90%E7%A0%81%E8%A7%A3%E8%AF%BB/">浅谈Vue3响应式原理与源码解读</a>
          </li>
        
          <li>
            <a href="/2023/04/01/setState%E4%B8%8EuseState%E4%BD%BF%E7%94%A8%E6%B3%A8%E6%84%8F%E9%A1%B9/">setState与useState使用注意项</a>
          </li>
        
          <li>
            <a href="/2023/02/06/%E4%BD%BF%E7%94%A8useReducer%20+%20useContext%20%E4%BB%A3%E6%9B%BF%20react-redux/">使用useReducer + useContext 代替 react-redux</a>
          </li>
        
          <li>
            <a href="/2022/11/15/GitHub%20Actions%20%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2%E5%89%8D%E7%AB%AF%20Vue%20%E9%A1%B9%E7%9B%AE/">GitHub Actions 自动部署前端 Vue 项目</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      
      &copy; 2023 chenXming<br>
      Powered by <a href="https://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>

    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    


<script src="/js/jquery-3.6.4.min.js"></script>



  
<script src="/fancybox/jquery.fancybox.min.js"></script>




<script src="/js/script.js"></script>





  </div>
</body>
</html>